# React Hook

## 리액트 훅

### 도입 이유

상태를 관리할 때 데이터를 componentDidMount 나 componentDidUpdate 에서 가져오기도 한다. 그리고 이벤트 리스너 설정 등을 마운트에 걸수도 있고 이런 코드가 분리가 된 거 같지만 완벽히 분리된 게 아니니까 버그 발생 이슈가 높고 테스팅이 어렵다.\(재사용성도 이슈가 있음\) 그래서 상태관리 라이브러리를 사용하게 된다.

=&gt; 수명주기 기준으로 데이터가 관리됨

훅을 쓰면 클래스 없이 더 많은 걸 사용할 수 있다.

* 최상위 레벨에서만 훅을 호출 : 루프, 조건, 중첩함수 내부에서 호출하면 안됨.
* state 변경하는 함수는 렌더링 과정에 포함되면 안됨. 무한루프가 걸림.

ref 는 useRef 를 쓴다. const \[inpT, setInput\] = useState\(\(\) =&gt; createRef\(\)\); 이와 같은 식으로 createRef\(\) 로 useState 의 초기값을 잡아 준다 =&gt; 기존 클래스 컴포넌트에서 함수형 ref 를 썼던 것과 같음.

정리하면 const \[상태변수명, 상태를설정할 함수명\] = useState\(초기상태값\);

useState 라는 함수를 배열로 해체할당하여 새로운 상태와 상태를 수정할 함수를 정의한다. useEffect 는 컴포넌트 마운트와 디드업데이트의 과정을 통합하여, 돔 업데이트가 완료되었음을 보장한 후 수행된다. effect 자체는 항상 렌더링때마다 새롭게 교체된다. =&gt;클래스형 컴포넌트에서 마운트, 언마운트 시 내용을 초기화하는 경우가 필요 없다.

만약 ref 일 경우엔 초기상태값이 함수형태 ref 이여야 하므로 \(\) =&gt; createRef\(\) 인 것

useEffect 는 브라우저 화면 업데이트와는 별개로 수행되므로 만약 브라우저 동기실행이 필요한 경우 useLayoutEffect 를 실행해야 한다.

